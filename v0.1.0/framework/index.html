<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>OPFLearn Framework · OPFLearn</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://NREL.github.io/OPFLearn.jl/framework/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="OPFLearn logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">OPFLearn</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickstartguide/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>OPFLearn Framework</a><ul class="internal"><li><a class="tocitem" href="#Dataset-Creation-Method-Overview"><span>Dataset Creation Method Overview</span></a></li><li><a class="tocitem" href="#Framework"><span>Framework</span></a></li><li><a class="tocitem" href="#Additional-Dataset-Creation-Arguments"><span>Additional Dataset Creation Arguments</span></a></li></ul></li><li><a class="tocitem" href="../results/">Result Data</a></li><li><a class="tocitem" href="../dataset/">Dataset Format</a></li><li><a class="tocitem" href="../distributed/">Distributed Processing</a></li><li><a class="tocitem" href="../python/">Python Interface</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../datasetcreation/">Dataset Creation</a></li><li><a class="tocitem" href="../saving/">Exporting Datasets</a></li><li><a class="tocitem" href="../sampling/">Sampling</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>OPFLearn Framework</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>OPFLearn Framework</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL/OPFLearn.jl/blob/master/docs/src/framework.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="OPFLearn-Framework"><a class="docs-heading-anchor" href="#OPFLearn-Framework">OPFLearn Framework</a><a id="OPFLearn-Framework-1"></a><a class="docs-heading-anchor-permalink" href="#OPFLearn-Framework" title="Permalink"></a></h1><h2 id="Dataset-Creation-Method-Overview"><a class="docs-heading-anchor" href="#Dataset-Creation-Method-Overview">Dataset Creation Method Overview</a><a id="Dataset-Creation-Method-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Creation-Method-Overview" title="Permalink"></a></h2><p>OPFLearn uses an efficient methodology to representatively sample from significant portions of the AC OPF feasible load space. This methodology finds load samples by uniformly sampling from a convex set, the input space, which contains an AC OPF feasible set.  Samples are then tested for AC OPF feasibility and are added to the dataset if they are feasible.  The convex set is reduced throughout sampling by constructing separating hyperplanes to increase the likelihood of sampling feasible load profiles.</p><p>A flowchart of the OPFLearn framework can be seen below,</p><div style="background-color:white; display:block; margin-left:auto; margin-right:auto; width:80%" >
<img src='../assets/flowchart.svg' style="display:block; margin-left:auto; margin-right:auto" width="100%" alt='OPFLearn flowchart'>
</div><p>The loop exits when one of the given stopping conditions is met.  Generally, this stopping criteria is the number of desired samples in the dataset.</p><p>Example iterations of this process are illustrated below where SOC represents the relaxed AC OPF feasible load space and AC represents the true AC OPF feasible load space. </p><div style="background-color:white; display:block; margin-left:auto; margin-right:auto; width:50%" >
<img src="../assets/procedure.svg" style="display:block; margin-left:auto; margin-right:auto" width="100%" alt="Iteration example">
</div><p><strong>Steps from top left to bottom right:</strong> </p><p>(1) Find the Chebyshev center to use as the initial point, <span>$x_0$</span>. Generate a random direction vector and travel a random distance along this vector to find a new load sample, <span>$x_l$</span>. </p><p>(2) Check if <span>$x_l$</span> is AC OPF feasible. If it is not feasible, find the nearest relaxed feasible point, <span>$x_l^*$</span>. Because <span>$\hat{x}_l \ne {x}_l^*$</span> define a new infeasibility certificate at <span>$x_l^*$</span> with normal, <span>$\vec{n} = \hat{x}_l - {x}_l^*$</span>. </p><p>(3) Gather a new sample, <span>$x_l$</span>, as in Step 1. Check if the new sampled load is AC OPF feasible. Here, it is not, so the nearest relaxed feasible point is found. <span>$\hat{x}_l = x^*_l$</span> so discard this sample. </p><p>(4) Sample a new load profile, <span>$x_l$</span>, as in Step 1, but starting from the last point, now <span>$x_0$</span>. Check if <span>$x_l$</span> is AC OPF feasible. <span>$x_l$</span> is AC OPF feasible, so store <span>$x_l$</span> and its AC OPF optimal solution.</p><h2 id="Framework"><a class="docs-heading-anchor" href="#Framework">Framework</a><a id="Framework-1"></a><a class="docs-heading-anchor-permalink" href="#Framework" title="Permalink"></a></h2><p>OPFLearn was developed to allow the user to specify functions for generalizable parts of the dataset creation process. The following operations in the OPFLearn framework can be modified by the user. </p><ul><li><strong>Initial Sampling Space</strong>: The A and b matrices defining a polytope, Ax ≤ b.</li><li><strong>Sampling Method</strong>: A function to sample network load profiles given the current sampling space and nominal load.</li><li><strong>AC OPF Relaxations</strong>: The AC OPF problem relaxations used to find the maximum load demands and nearest feasible loads.</li><li><strong>Optimization Solvers</strong>: Solvers used to solve the relaxed and nonconvex AC OPF problems.</li></ul><h3 id="Initial-Sampling-Space"><a class="docs-heading-anchor" href="#Initial-Sampling-Space">Initial Sampling Space</a><a id="Initial-Sampling-Space-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Sampling-Space" title="Permalink"></a></h3><p>The initial sampling space can be specified by provided A and b matrices that define a polytope, Ax ≤ b.  By default this sampling space is initialized with the following constraints, </p><ul><li>The active demand is less than the found maximum individual load bus demand values,</li><li>The active demand is greater than zero,</li><li>The reactive demand is greater than zero,</li><li>The reactive demand is less than the active demand at each load bus,</li><li>The total active load is less than the sum of generator active power ratings.</li></ul><h3 id="Sampling-Method"><a class="docs-heading-anchor" href="#Sampling-Method">Sampling Method</a><a id="Sampling-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-Method" title="Permalink"></a></h3><p>A function for sampling load profiles for the network can be provided to the dataset creation functions through the <code>sampler</code> argument. This function must accept four required arguments A, b, x0, n<em>samples, where A &amp; b define the sampling space as a polytope, x0 is a point within the sampling space, and n</em>samples is the number of samples to produce. Additionally the function can accept any number of optional arguments, which can be provided through the <code>sampler_opts</code> arguments as a dictionary mapping optional argument names as symbols to the desired parameter (e.g. :method =&gt; &quot;hitandrun&quot;).</p><p>By default OPFLearn uses a <a href="https://www.mathworks.com/matlabcentral/fileexchange/34208-uniform-distribution-over-a-convex-polytope?s_tid=prof_contriblnk">hit and run sample method translated from MATLAB (Copyright (c) 2011, Tim Benham).</a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note only the hit and run methods (hitandrun &amp; achr) in the OPFLearn <a href="../sampling/#OPFLearn.sample_polytope_cprnd"><code>sample_polytope_cprnd</code></a> function have been extensively tested.</p></div></div><h3 id="AC-OPF-Relaxations"><a class="docs-heading-anchor" href="#AC-OPF-Relaxations">AC OPF Relaxations</a><a id="AC-OPF-Relaxations-1"></a><a class="docs-heading-anchor-permalink" href="#AC-OPF-Relaxations" title="Permalink"></a></h3><p>The relaxations to formulate relaxed AC OPF problems can be specified with the <code>model_type</code> argument for dataset creation functions.  Most relaxations available in the PowerModels.jl package can be used. A list of these <a href="https://lanl-ansi.github.io/PowerModels.jl/stable/formulation-details/#Quadratic-Relaxations">PowerModels relaxations can be found here</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that for conic relaxations a nondefault solver will likely need for be used.</p></div></div><h3 id="Optimization-Solvers"><a class="docs-heading-anchor" href="#Optimization-Solvers">Optimization Solvers</a><a id="Optimization-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Solvers" title="Permalink"></a></h3><p>The solvers used for solving the relaxed and nonconvex AC OPF problems can be specified with <code>r_solver</code> and <code>opf_solver</code>, respectively. By default <a href="https://github.com/jump-dev/Ipopt.jl">IPOPT</a> is used to solve all AC OPF problems.</p><h2 id="Additional-Dataset-Creation-Arguments"><a class="docs-heading-anchor" href="#Additional-Dataset-Creation-Arguments">Additional Dataset Creation Arguments</a><a id="Additional-Dataset-Creation-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Dataset-Creation-Arguments" title="Permalink"></a></h2><p>A complete list of arguments for the <code>create_samples</code> can be found in the functions documentation,</p><article class="docstring"><header><a class="docstring-binding" id="OPFLearn.create_samples" href="#OPFLearn.create_samples"><code>OPFLearn.create_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Loads in PowerModels network data given the name of a network case file,  then starts creating samples</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/OPFLearn.jl/blob/49bb17e276ff553253ac4e4a91c864fe2035a1f2/src/create_samples.jl#L1-L4">source</a></section><section><div><pre><code class="language-julia hljs">create_samples(net, K; &lt;keyword arguments&gt;)</code></pre><p>Creates an AC OPF dataset for the given PowerModels network dictionary. Generates samples until one of the given stopping criteria is met.  Takes options to determine how to sample points, what information to save, and what information is printed.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; results = create_samples(&quot;case5.m&quot;, 100; T=1000, net_path=&quot;data&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li>&#39;net::Dict&#39;: network information stored in a PowerModels.jl format specified dictionary</li><li>&#39;K::Integer&#39;: the maximum number of samples before stopping sampling</li><li>&#39;U::Float&#39;: the minimum % of unique active sets sampled in the previous 1 / U samples to continue sampling</li><li>&#39;S::Float&#39;: the minimum % of saved samples in the previous 1 / L samples to continue sampling</li><li>&#39;V::Float&#39;: the minimum % of feasible samples that increase the variance of the dataset in the previous 1 / L samples to continue sampling</li><li>&#39;T::Integer&#39;: the maximum time for the sampler to run in seconds.</li><li>&#39;max_iter::Integer&#39;: maximum number of iterations for the sampler to run for.</li><li>&#39;sampler::Function&#39;: the sampling function to use. This function must take arguements A and b, and can take optional arguments.</li><li>&#39;sampler_opts::Dict&#39;: a dictionary of optional arguments to pass to the sampler function.</li><li>&#39;A::Array&#39;: defines the initial sampling space polytope Ax&lt;=b. If not provided, initializes to a default.</li><li>&#39;b::Array&#39;: defines the initial sampling space polytope Ax&lt;=b. If not provided, initializes to a default.</li><li>&#39;pl_max::Array&#39;: the maximum active load values to use when initializing the sampling space and constraining the loads. If nothing, finds the maximum load at each bus with the given relaxed model type.</li><li>&#39;pf_min::Array/Float:&#39; the minimum power factor for all loads in the system (Number) or an array of minimum power factors for each load in the system.</li><li>&#39;pf_lagging::Bool&#39;: indicating if load power factors can be only lagging (True), or both lagging or leading (False).</li><li>&#39;reset_level::Integer&#39;: determines how to reset the load point to be inside the polytope before sampling. 2: Reset closer to nominal load &amp; chebyshev center, 1: Reset closer to chebyshev center, 0: Reset at chebyshev center.</li><li>&#39;save_certs::Bool&#39;: specifies whether the sampling space, Ax&lt;=b (A &amp; b matrices) are saved to the results dictionary.</li><li>&#39;save<em>max</em>load::Bool&#39;: specifies whether the max active load demands used are saved to the results dictionary.</li><li>&#39;model_type::Type&#39;: an abstract PowerModels type indicating the network model to use for the relaxed AC-OPF formulations (Max Load &amp; Nearest Feasible)</li><li>&#39;r_solver&#39;: an optimizer constructor used for solving the relaxed AC-OPF optimization problems.</li><li>&#39;opf_solver&#39;: an optimizer constructor used to find the AC-OPF optimal solution for each sample.</li><li>&#39;print_level::Integer&#39;: from 0 to 3 indicating the level of info to print to console, with 0 indicating minimum printing.</li><li>&#39;stat_track::Integer&#39;: from 0 to 3 indicating the level of stats info saved during each iteration	0: No information saved, 1: Feasibility, New Certificate, Added Sample, Iteration Time, 2: Variance for all input &amp; output variables</li><li>&#39;save_while::Bool&#39;: indicates whether results and stats information is saved to a csv file during processing.</li><li>&#39;save_infeasible::Bool&#39;: indicates if infeasible samples are saved. If true saves infeasible samples in a seperate file from feasible samples.</li><li>&#39;save_path::String:&#39; a string with the file path to the desired result save location.</li><li>&#39;net_path::String&#39;: a string with the file path to the network file. </li><li>&#39;variance::Bool&#39;: indicates if dataset variance information is tracked for each unique active set.</li><li>&#39;discard::Bool&#39;: indicates if samples that do not increase the variance within a unique active set are discarded.</li></ul><p>See &#39;OPF-Learn: An Open-Source Framework for Creating Representative AC Optimal Power Flow Datasets&#39; for more information on how the AC OPF datasets are created. </p><p>Modified from AgenerateACOPFsamples.m written by Ahmed Zamzam</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/OPFLearn.jl/blob/49bb17e276ff553253ac4e4a91c864fe2035a1f2/src/create_samples.jl#L24-L70">source</a></section></article><h3 id="Stopping-Criteria"><a class="docs-heading-anchor" href="#Stopping-Criteria">Stopping Criteria</a><a id="Stopping-Criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Stopping-Criteria" title="Permalink"></a></h3><p>The criteria used to stop sampling can be set to include any of the following, </p><ul><li>K: The maximum number of samples</li><li>U: 1/U indicates the maximum number of samples since the last unique active set found</li><li>S: 1/S indicates the maximum number of samples since the last sample was saved to the dataset</li><li>V: 1/V indicates the maximum number of samples since the last feasible sample increased the variance of its unique active set</li><li>T: The maximum amount of time for the creation of the dataset</li><li>max_iter: The maximum amount of total iterations when creating the dataset</li></ul><p>When multiple criteria are used, sampling will stop when any one of the used criteria are satisfied. To exclude the maximum number of samples criteria set K to Inf (np.Inf in Python).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstartguide/">« Getting Started</a><a class="docs-footer-nextpage" href="../results/">Result Data »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Sunday 17 October 2021 21:47">Sunday 17 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
