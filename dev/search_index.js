var documenterSearchIndex = {"docs":
[{"location":"dataset/#Dataset-Format","page":"Dataset Format","title":"Dataset Format","text":"","category":"section"},{"location":"dataset/","page":"Dataset Format","title":"Dataset Format","text":"The results are returned as a dictionary, which can be converted to an array with the results_to_array function. This resulting array has the same format as the exported datasets from results_to_csv. ","category":"page"},{"location":"dataset/","page":"Dataset Format","title":"Dataset Format","text":"The array formatted datasets have column headers indicating variables and each row contains the data for one sample. Columns are organized with variables in the order of input variables, output variables, then dual variables. The order  of variables within each section is determined by the order of the variables given through the result variable array arguments. For each variable there is a column corresponding to each element in the network.  The header for a column indicating the active power demand at the first load bus would be \"load1:pd\". An example results 'csv' file header can be seen below for the pjm case5 network,","category":"page"},{"location":"dataset/","page":"Dataset Format","title":"Dataset Format","text":"load1:pd load2:pd load3:pd load1:qd load2:qd load3:qd gen1:p_gen gen2:p_gen ...\n4.593425 6.023329 3.397289 2.522202 1.098917 0.522865 0.4 1.7 ...\n4.516742 4.325241 5.034486 1.025272 1.499984 3.382087 0.4 1.7 ...\n3.936777 5.626792 1.330743 2.183705 0.385759 1.027381 0.4 1.363544 ...\n... ... ... ... ... ... ... ... ...","category":"page"},{"location":"quickstartguide/#Quick-Start-Guide","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"With OPFLearn installed and a network data file (e.g. \"pglib_opf_case5_pjm.m\") available in the current directory, an AC OPF dataset with N samples can be created with,","category":"page"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"using OPFLearn\nN = 100\n\nresults = create_samples(\"pglib_opf_case5_pjm.m\", N)","category":"page"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"note: Note\nWhen creating datasets for networks with greater than around 50 buses, runtimes can be improved by reducing the initial sampling space through either the 'pdmax', 'pdmin', or 'pfmin' arguments. OPFLearn has been tested on networks up to 300 buses with 'pdmax' specified as 2 times the nominal load at each bus. For 'pglibopfcase300_ieee' a dataset of 15,000 samples took approximately a day to create using 40 distributed processors on an HPC node.","category":"page"},{"location":"quickstartguide/#Getting-Results","page":"Getting Started","title":"Getting Results","text":"","category":"section"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"OPFLearn's create_samples functions return the resulting sample data as a dictionary.  This dictionary contains sub-dictionaries containing feasible AC OPF sample input, output, and lagrangian dual values.  Each of these three primary data category's dictionaries map variable key values to arrays containing the corresponding data for relevent elements in the network.  These arrays are two dimensional with columns corresponding to elements in the system and rows corresponding to different AC OPF samples. ","category":"page"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"The input data, queried with results[\"inputs\"], is a dictionary containing information for input variables to the AC OPF problem. The output data, queried with results[\"outputs\"], is a dictionary of AC OPF solutions corresponding to the input data load profiles. The dual data, queried with results[\"duals\"], is a dictionary containing information about the lagrangian dual values found when solving the AC OPF problem for each sample. Nonzero values (In OPFLearn values greater than 1e-5) indicate that the contraint associated with a dual value is active.","category":"page"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"For example, the following dictionary query can be used to find the active power, pd, at each load in the network for the first saved AC OPF sample,","category":"page"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"results[\"inputs\"][\"pd\"][1,:]","category":"page"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"Note that input and output data is in per unit. The base MVA can be found from the PowerModels network data dictionary.","category":"page"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"By default input, output, and dual result data for all variables are saved to the results object.  To reduce the size of the resulting data an array of the desired variables can be provided in the create samples call.  For example, if you are only interested in saving the generator active power, pg, and generator bus voltage magnitudes, vm_gen, the following call can be made,","category":"page"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"outputs = [\"pg\", \"vm_gen\"]\nresults = create_samples(\"pglib_opf_case5_pjm.m\", N, output_vars=outputs)","category":"page"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"This results object will only contain output data for these two specified output varaibles. Note, the input and dual results will still contain all the default variables, unless also specified.","category":"page"},{"location":"quickstartguide/#Additional-Results","page":"Getting Started","title":"Additional Results","text":"","category":"section"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"More information from each run can be saved by specifying additional parameters when calling create samples.  This information includes iteration statistics, found maximum load bus demands, infeasible AC OPF samples, and the sampling space polytope definition. See the Additional Results section for instructions on how to enable saving these additional results.","category":"page"},{"location":"quickstartguide/#Distributed-Processing","page":"Getting Started","title":"Distributed Processing","text":"","category":"section"},{"location":"quickstartguide/","page":"Getting Started","title":"Getting Started","text":"If there are multiple processors available, the runtime to create samples can be reduced by using distributed processing.  OPFLearn has addition functions for creating AC OPF datasets that utilize distributed processing, which can be read about in the Distributed Processing section.","category":"page"},{"location":"results/#OPFLearn-Result-Data","page":"Result Data","title":"OPFLearn Result Data","text":"","category":"section"},{"location":"results/#Result-Dataset-Dictionary","page":"Result Data","title":"Result Dataset Dictionary","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"Resulting datasets are returned as a dictionary of values. This dictionary uses strings as key values. A default result dictionary contains inputs, outputs, and duals data, structured as follows.","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"{\n\"inputs\":<Dictionary>,  # input variables to the AC OPF problem\n\"outputs\":<Dictionary>, # AC OPF solutions corresponding to the input load profiles\n\"duals\":<Dictionary>,   # lagrangian dual values found when solving the AC OPF problem\n...\n}","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"Each of these default result keys maps to a dictionary containing variables from the AC OPF problem that map to an array of result values for each sample in the dataset. For example, the inputs, results[\"inputs\"], would return the following dictionary with active and reactive load variables mapping to a 2-dimensional array of values.","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"{\n\"pd\": [...],\n\"qd\": [...],\n}","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"Then looking at the data for the active load with key \"pl\", results[\"inputs\"][\"pl\"], would return an array structured as follows,","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"sample 1: [pd_1, pd_2, ..., pd_n]\nsample 2: [pd_1, pd_2, ..., pd_n]\nsample 3: [pd_1, pd_2, ..., pd_n]\n...\nsample K: [pd_1, pd_2, ..., pd_n]","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"where pd_n indicates the value of the active power demand at bus n. ","category":"page"},{"location":"results/#Specifying-Results","page":"Result Data","title":"Specifying Results","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"By default input, output, and dual result data for all variables are saved to the results object.  To reduce the size of the result object a subsection of the variables to save can be provided in the create samples call.  For example, if you are only interested in saving the generator active power, pg, generator bus voltage magnitudes, vm_gen, and the AC OPF objective value, \"total_cost\", the following call can be made,","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"outputs = [\"p_gen\", \"vm_gen\", \"total_cost\"]\nresults = create_samples(\"pglib_opf_case5_pjm.m\", N, output_vars=outputs)","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"This results object will only contain subdictionaries for these two specified output varaibles. The input and dual results will still contain all the default variables, unless also specified.","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"All the available result variables can be seen in this table,","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"<table>\n  <tbody>\n    <tr>\n\t\t<th><b>Input Data</b></th>\n\t\t<th><b>Output Data</b></th>\n\t\t<th><b>Dual Data</b></th>\n\t</tr>\n\t\n    <tr>\n\t\t<td>\n\t\t\t<ul><li>Load Active Power (pd)</li><li>Load Reactive Power (qd)\n\t\t\t</li></ul>\n\t\t</td>\n\t\t<td>\t\n\t\t\t<ul><li>Generator Active Power (p_gen)</li><li>Generator Reactive Power (q_gen)</li><li>Generator Bus Voltage Magnitude (vm_gen)</li><li>Bus Complex Voltage (v_bus)</li><li>Bus Voltage Magnitude (vm_bus)</li><li>Bus Voltage Angle (va_bus)</li><li>Edge To Active Power (p_to)</li><li>Edge From Active Power (p_fr)</li><li>Edge To Reactive Power (q_to)</li><li>Edge From Reactive Power (q_fr)</li></ul>\n\t\t</td>\n\t\t<td>\n\t\t\t<ul><li>Min Bus Voltage (v_min)</li><li>Max Bus Voltage (v_max)</li><li>Min Generator Active Power (pg_min)</li><li>Max Generator Active Power (pg_max)</li><li>Min Generator Reactive Power (qg_min)</li><li>Max Generator Reactive Power (qg_max)</li><li>Max Edge To Active Power (pto_max)</li><li>Max Edge From Active Power (pfr_max)</li><li>Max Edge To Reactive Power (qto_max)</li><li>Max Edge From Reactive Power (qfr_max)</li></ul>\n\t\t</td>\n\t</tr>\n  </tbody>\n</table>","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"By default all variables are stored to the results object, except for the bus complex voltage and total network cost. ","category":"page"},{"location":"results/#Converting-to-an-Array","page":"Result Data","title":"Converting to an Array","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"The result data dictionary can be converted to an array for easier data analysis with the results_to_array function.","category":"page"},{"location":"results/#additional_results","page":"Result Data","title":"Additional Results","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"Additional result parameters can be saved if specified in the function call to create the dataset. The additional results parameters are, ","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"Iteration Statistics:\nSampling Polytope:  \nFound Maximum Loads: \nInfeasible Inputs: ","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"Arguments can be passed in to the dataset creation function, to have these additional results in the results dictionary.","category":"page"},{"location":"results/#Iteration-Statistics","page":"Result Data","title":"Iteration Statistics","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"To save iteration statistics the stat_track argument can be specified as an Integer from 1 to 3.","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"results = create_samples(net_file, K, stat_track=1)","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"Specifying a larger integer will save more information as follows,","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"Stat Track Level Additional Data Saved\n0 None\n1 New Unique Active Set, New Infeasibility Certificate, Feasible Sample, Added Sample, Iteration Time, Increased Set Variance\n2 Unique Active Sets in The Dataset\n3 Unique Active Set Covariance Matrices","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"This information can then be found in the results dictionary with results[\"stats\"]. ","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"warn: Warn\nFor large datasets or networks using a level greater than 1 will likely result in a large amount of memory usage and slow down the dataset creation process.","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"note: Note\nVariance tracking needs to be turned on with the boolean variance argument for data to be saved with stat_track=3.","category":"page"},{"location":"results/#Sampling-Polytope","page":"Result Data","title":"Sampling Polytope","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"To save the polytope that was used for sampling the save_certs argument should be specified as true.","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"results = create_samples(net_file, K, save_certs=true)","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"This will save the final definition of the polytope used for sampling input load demands, including the infeasibility certificates added to the initial sampling space. The polytope is defined by Ax <= b, where A and b are matrices and x is a vector of the demands at each load bus in the network.  Each row of the A and b matrices specifies a hyperplane contraint that defines the input load space that samples are pulled from. These matrices are stored as arrays at results[\"polytope\"][\"A\"] and results[\"polytope\"][\"b\"]. These matrices can be passed into a new call to a dataset creation function, with the arguments A and b, to initialize the sampling polytope with this polytope containing the infeasibility certificates found during the last run. ","category":"page"},{"location":"results/#Found-Maximum-Loads","page":"Result Data","title":"Found Maximum Loads","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"To save the maximum loads used to initialize the input load space the save_max_load argument should be specified as true.","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"results = create_samples(net_file, K, save_max_load=true)","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"This will store an array of maximum loads found at each bus in the network at results[\"load_constraints\"][\"pd_max\"].  This array can be provided as an argument, pd_max, to a dataset creation function, when using the same network, to reduce the dataset creation initialization time.","category":"page"},{"location":"results/#Infeasible-Inputs","page":"Result Data","title":"Infeasible Inputs","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"To save the infeasible AC OPF load samples found throughout dataset creation the save_infeasible argument should be specified as true.","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"results = create_samples(net_file, K, save_infeasible=true)","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"These results, at results[\"infeasible_inputs\"], contain all AC OPF infeasible load profiles input values found during the creation of a dataset.","category":"page"},{"location":"results/#Exporting-Results","page":"Result Data","title":"Exporting Results","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"Multiple functions are available to save OPFLearn datasets and other result data to 'csv' files.","category":"page"},{"location":"results/#Dataset","page":"Result Data","title":"Dataset","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"To export an AC OPF dataset the save_results_csv function can be used as follows, ","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"results = create_samples(net_file, K)\nfile_name = \"dataset\"\nsave_results_csv(results, file_name)","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"where results contains the dataset to be saved, and file_name is the name that the file will be saved as. The format of the exported results 'csv' file is explained in the Dataset Format Section","category":"page"},{"location":"results/#Statistics","page":"Result Data","title":"Statistics","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"Similarly, to export the iteration statistics the function save_stats can be used as follows,","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"stats = results[\"stats\"]\nsave_stats(stats, file_name)","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"Note that this only saves the statistics stored with stat_track=1.","category":"page"},{"location":"results/#Polytope","page":"Result Data","title":"Polytope","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"To export the Polytope A and b matrices the function save_polytope can be used as follows,","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"A = results[\"polytope\"][\"A\"]\nb = results[\"polytope\"][\"b\"]\nsave_polytope(A, b, file_name)","category":"page"},{"location":"results/","page":"Result Data","title":"Result Data","text":"Note that this saves the A and b matrices in two seperate 'csv' files.","category":"page"},{"location":"results/#Save-While-Processing","page":"Result Data","title":"Save While Processing","text":"","category":"section"},{"location":"results/","page":"Result Data","title":"Result Data","text":"The save_while argument can be specified as true to save all result values to files during the creation of the AC OPF dataset. This ensures that dataset results are not lost if an error is encountered during the creation of large datasets.  All values are saved to 'csv' files. ","category":"page"},{"location":"framework/#OPFLearn-Framework","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"","category":"section"},{"location":"framework/#Dataset-Creation-Method-Overview","page":"OPFLearn Framework","title":"Dataset Creation Method Overview","text":"","category":"section"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"OPFLearn uses an efficient methodology to representatively sample from significant portions of the AC OPF feasible load space. This methodology finds load samples by uniformly sampling from a convex set, the input space, which contains an AC OPF feasible set.  Samples are then tested for AC OPF feasibility and are added to the dataset if they are feasible.  The convex set is reduced throughout sampling by constructing separating hyperplanes to increase the likelihood of sampling feasible load profiles.","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"A flowchart of the OPFLearn framework can be seen below,","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"<div style=\"background-color:white; display:block; margin-left:auto; margin-right:auto; width:80%\" >\n<img src='../assets/flowchart.svg' style=\"display:block; margin-left:auto; margin-right:auto\" width=\"100%\" alt='OPFLearn flowchart'>\n</div>","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"The loop exits when one of the given stopping conditions is met.  Generally, this stopping criteria is the number of desired samples in the dataset.","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"Example iterations of this process are illustrated below where SOC represents the relaxed AC OPF feasible load space and AC represents the true AC OPF feasible load space. ","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"<div style=\"background-color:white; display:block; margin-left:auto; margin-right:auto; width:50%\" >\n<img src=\"../assets/procedure.svg\" style=\"display:block; margin-left:auto; margin-right:auto\" width=\"100%\" alt=\"Iteration example\">\n</div>","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"Steps from top left to bottom right: ","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"(1) Find the Chebyshev center to use as the initial point, x_0. Generate a random direction vector and travel a random distance along this vector to find a new load sample, x_l. ","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"(2) Check if x_l is AC OPF feasible. If it is not feasible, find the nearest relaxed feasible point, x_l^*. Because hatx_l ne x_l^* define a new infeasibility certificate at x_l^* with normal, vecn = hatx_l - x_l^*. ","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"(3) Gather a new sample, x_l, as in Step 1. Check if the new sampled load is AC OPF feasible. Here, it is not, so the nearest relaxed feasible point is found. hatx_l = x^*_l so discard this sample. ","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"(4) Sample a new load profile, x_l, as in Step 1, but starting from the last point, now x_0. Check if x_l is AC OPF feasible. x_l is AC OPF feasible, so store x_l and its AC OPF optimal solution.","category":"page"},{"location":"framework/#Framework","page":"OPFLearn Framework","title":"Framework","text":"","category":"section"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"OPFLearn was developed to allow the user to specify functions for modular parts of the dataset creation process. The following operations in the OPFLearn framework can be provided by the user. ","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"Initial Sampling Space: The A and b matrices defining a polytope, Ax ≤ b.\nSampling Method: A function to sample network load profiles given the current sampling space and nominal load.\nAC OPF Relaxations: The AC OPF problem relaxations used to find the maximum load demands and nearest feasible loads.\nOptimization Solvers: Solvers used to solve the relaxed and nonconvex AC OPF problems.","category":"page"},{"location":"framework/#Initial-Sampling-Space","page":"OPFLearn Framework","title":"Initial Sampling Space","text":"","category":"section"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"The initial sampling space can be specified by provided A and b matrices that define a polytope, Ax ≤ b.  By default this sampling space is initialized with the following constraints, ","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"The active demand is less than the found maximum individual load bus demand values,\nThe active demand is greater than zero,\nThe reactive demand is greater than zero,\nThe reactive demand is limited by the specified minimum power factor (default: 0.7071),\nThe total active load is less than the sum of generator active power ratings.","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"The default initial sampling space is impacted by the following arguments,","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"'pd_max': The maximum active load for each load in the system. By default this is found with an optimization problem.\n'pd_min': The minimum active load for each load in the system. By default this is 0.\n'pf_min': A single number or array with values for each load in the system indicating the minimum power factor.\n'pf_lagging': A boolean indicating if the power factor of loads are only lagging (inductive), or can be lagging or leading (inductive or capacitive).","category":"page"},{"location":"framework/#Sampling-Method","page":"OPFLearn Framework","title":"Sampling Method","text":"","category":"section"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"A function for sampling load profiles from the sample space can be provided to the dataset creation functions through the sampler argument. This function must accept four required arguments A, b, x0, n_samples, where A & b define the sampling space as a polytope (Ax<b), x0 is a point within the sampling space, and n_samples is the number of samples to produce. Additionally the function can accept any number of optional arguments, which can be provided through the sampler_opts arguments as a dictionary mapping optional argument names as symbols to the desired parameter (e.g. :method => \"hitandrun\").","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"By default OPFLearn uses a hit and run sample method translated from MATLAB (Copyright (c) 2011, Tim Benham).","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"note: Note\nNote only the hit and run methods (hitandrun & achr) in the OPFLearn sample_polytope_cprnd function have been extensively tested.","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"warn: Warn\nWhen creating datasets for networks with greater than around 50 loads, the default sampling method can become slow do to the high dimensionality of the sampling space and the often large number of infeasibility certificates found. Changing the sampler or sampling parameters can help speed up sampling. ","category":"page"},{"location":"framework/#AC-OPF-Relaxations","page":"OPFLearn Framework","title":"AC OPF Relaxations","text":"","category":"section"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"The relaxations to formulate relaxed AC OPF problems can be specified with the model_type argument for dataset creation functions.  Most relaxations available in the PowerModels.jl package can be used. A list of these PowerModels relaxations can be found here. By default OPFLearn uses a Strengthened QC-Relaxation, 'PowerModels.QCLSPowerModel'.","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"note: Note\nNote that for conic relaxations, such as PowerModels.SDPWRMPowerModel, a non-default solver will likely need for be used.","category":"page"},{"location":"framework/#Optimization-Solvers","page":"OPFLearn Framework","title":"Optimization Solvers","text":"","category":"section"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"The solvers used for solving the relaxed and nonconvex AC OPF problems can be specified with r_solver and opf_solver, respectively. By default IPOPT is used to solve all AC OPF problems.","category":"page"},{"location":"framework/#Additional-Dataset-Creation-Arguments","page":"OPFLearn Framework","title":"Additional Dataset Creation Arguments","text":"","category":"section"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"A complete list of arguments for the create_samples can be found in the functions documentation,","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"create_samples","category":"page"},{"location":"framework/#OPFLearn.create_samples","page":"OPFLearn Framework","title":"OPFLearn.create_samples","text":"Loads in PowerModels network data given the name of a network case file,  then starts creating samples\n\n\n\n\n\ncreate_samples(net, K; <keyword arguments>)\n\nCreates an AC OPF dataset for the given PowerModels network dictionary. Generates samples until one of the given stopping criteria is met.  Takes options to determine how to sample points, what information to save, and what information is printed.\n\nExamples\n\njulia> results = create_samples(\"case5.m\", 100; T=1000, net_path=\"data\")\n\nArguments\n\n'net::Dict': network information stored in a PowerModels.jl format specified dictionary\n'K::Integer': the maximum number of samples before stopping sampling\n'U::Float': the minimum % of unique active sets sampled in the previous 1 / U samples to continue sampling\n'S::Float': the minimum % of saved samples in the previous 1 / L samples to continue sampling\n'V::Float': the minimum % of feasible samples that increase the variance of the dataset in the previous 1 / L samples to continue sampling\n'T::Integer': the maximum time for the sampler to run in seconds.\n'max_iter::Integer': maximum number of iterations for the sampler to run for.\n'sampler::Function': the sampling function to use. This function must take arguements A and b, and can take optional arguments.\n'sampler_opts::Dict': a dictionary of optional arguments to pass to the sampler function.\n'A::Array': defines the initial sampling space polytope Ax<=b. If not provided, initializes to a default.\n'b::Array': defines the initial sampling space polytope Ax<=b. If not provided, initializes to a default.\n'pd_max::Array': the maximum active load values to use when initializing the sampling space and constraining the loads. If nothing, finds the maximum load at each bus with the given relaxed model type.\n'pd_min::Array': the minimum active load values to use when initializing the sampling space and constraining the loads. If nothing, this is set to 0 for all loads.\n'pf_min::Array/Float:' the minimum power factor for all loads in the system (Number) or an array of minimum power factors for each load in the system.\n'pf_lagging::Bool': indicating if load power factors can be only lagging (True), or both lagging or leading (False).\n'reset_level::Integer': determines how to reset the load point to be inside the polytope before sampling. 2: Reset closer to nominal load & chebyshev center, 1: Reset closer to chebyshev center, 0: Reset at chebyshev center.\n'save_certs::Bool': specifies whether the sampling space, Ax<=b (A & b matrices) are saved to the results dictionary.\n'save_max_load::Bool': specifies whether the max active load demands used are saved to the results dictionary.\n'model_type::Type': an abstract PowerModels type indicating the network model to use for the relaxed AC-OPF formulations (Max Load & Nearest Feasible)\n'r_solver': an optimizer constructor used for solving the relaxed AC-OPF optimization problems.\n'opf_solver': an optimizer constructor used to find the AC-OPF optimal solution for each sample.\n'print_level::Integer': from 0 to 3 indicating the level of info to print to console, with 0 indicating minimum printing.\n'stat_track::Integer': from 0 to 3 indicating the level of stats info saved during each iteration\t0: No information saved, 1: Feasibility, New Certificate, Added Sample, Iteration Time, 2: Variance for all input & output variables\n'save_while::Bool': indicates whether results and stats information is saved to a csv file during processing.\n'save_infeasible::Bool': indicates if infeasible samples are saved. If true saves infeasible samples in a seperate file from feasible samples.\n'save_path::String:' a string with the file path to the desired result save location.\n'net_path::String': a string with the file path to the network file. \n'variance::Bool': indicates if dataset variance information is tracked for each unique active set.\n'discard::Bool': indicates if samples that do not increase the variance within a unique active set are discarded.\n\nSee 'OPF-Learn: An Open-Source Framework for Creating Representative AC Optimal Power Flow Datasets' for more information on how the AC OPF datasets are created. \n\nModified from AgenerateACOPFsamples.m written by Ahmed S. Zamzam\n\n\n\n\n\n","category":"function"},{"location":"framework/#Stopping-Criteria","page":"OPFLearn Framework","title":"Stopping Criteria","text":"","category":"section"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"The criteria used to stop sampling can be set to include any of the following, ","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"K: The maximum number of samples\nU: 1/U indicates the maximum number of samples since the last unique active set found\nS: 1/S indicates the maximum number of samples since the last sample was saved to the dataset\nV: 1/V indicates the maximum number of samples since the last feasible sample increased the variance of its unique active set\nT: The maximum amount of time for the creation of the dataset\nmax_iter: The maximum amount of total iterations when creating the dataset","category":"page"},{"location":"framework/","page":"OPFLearn Framework","title":"OPFLearn Framework","text":"When multiple criteria are used, sampling will stop when any one of the used criteria are satisfied. To exclude the maximum number of samples criteria set K to Inf (np.Inf in Python).","category":"page"},{"location":"saving/#Exporting-Dataset-Functions","page":"Exporting Datasets","title":"Exporting Dataset Functions","text":"","category":"section"},{"location":"saving/","page":"Exporting Datasets","title":"Exporting Datasets","text":"Modules = [OPFLearn]\nPages   = [\"io.jl\"]\nOrder   = [:function]\nPrivate  = false","category":"page"},{"location":"saving/#OPFLearn.save_polytope-Tuple{Any, Any, Any}","page":"Exporting Datasets","title":"OPFLearn.save_polytope","text":"Saves the A and b matrices defining the polytope Ax < b to two seperate comma  delimited csv files.\n\n\n\n\n\n","category":"method"},{"location":"saving/#OPFLearn.save_results_csv-NTuple{4, Any}","page":"Exporting Datasets","title":"OPFLearn.save_results_csv","text":"Saves the AC_output, AC_input, duals to a csv file\n\n\n\n\n\n","category":"method"},{"location":"saving/#OPFLearn.save_stats-Tuple{Any, Any}","page":"Exporting Datasets","title":"OPFLearn.save_stats","text":"Saves the last iteration of level 1 stats to a csv file. If the csv file does not already exist then calls save_stats to save the stats data with a header to a new csv file.\n\n\n\n\n\n","category":"method"},{"location":"saving/#Managing-Results","page":"Exporting Datasets","title":"Managing Results","text":"","category":"section"},{"location":"saving/","page":"Exporting Datasets","title":"Exporting Datasets","text":"Modules = [OPFLearn]\nPages   = [\"results.jl\"]\nOrder   = [:function]\nPrivate  = false","category":"page"},{"location":"saving/#OPFLearn.results_to_array-Tuple{Any, Any, Any}","page":"Exporting Datasets","title":"OPFLearn.results_to_array","text":"Takes the results objects from a create samples run and converts them to a single array. Requires the save_order, an array of variables, to save from the results objects. Takes  optional boolean arguments header, whether to include a header as the first row, and  imag_j, whether to convert complex data values to strings and replace 'im' with 'j' for datasets that are to be used outside of the Julia environment.\n\n\n\n\n\n","category":"method"},{"location":"datasetcreation/#Dataset-Creation-Functions","page":"Dataset Creation","title":"Dataset Creation Functions","text":"","category":"section"},{"location":"datasetcreation/","page":"Dataset Creation","title":"Dataset Creation","text":"Modules = [OPFLearn]\nPages   = [\"create_samples.jl\"]\nOrder   = [:function]\nPrivate  = false","category":"page"},{"location":"datasetcreation/#OPFLearn.create_samples","page":"Dataset Creation","title":"OPFLearn.create_samples","text":"create_samples(net, K; <keyword arguments>)\n\nCreates an AC OPF dataset for the given PowerModels network dictionary. Generates samples until one of the given stopping criteria is met.  Takes options to determine how to sample points, what information to save, and what information is printed.\n\nExamples\n\njulia> results = create_samples(\"case5.m\", 100; T=1000, net_path=\"data\")\n\nArguments\n\n'net::Dict': network information stored in a PowerModels.jl format specified dictionary\n'K::Integer': the maximum number of samples before stopping sampling\n'U::Float': the minimum % of unique active sets sampled in the previous 1 / U samples to continue sampling\n'S::Float': the minimum % of saved samples in the previous 1 / L samples to continue sampling\n'V::Float': the minimum % of feasible samples that increase the variance of the dataset in the previous 1 / L samples to continue sampling\n'T::Integer': the maximum time for the sampler to run in seconds.\n'max_iter::Integer': maximum number of iterations for the sampler to run for.\n'sampler::Function': the sampling function to use. This function must take arguements A and b, and can take optional arguments.\n'sampler_opts::Dict': a dictionary of optional arguments to pass to the sampler function.\n'A::Array': defines the initial sampling space polytope Ax<=b. If not provided, initializes to a default.\n'b::Array': defines the initial sampling space polytope Ax<=b. If not provided, initializes to a default.\n'pd_max::Array': the maximum active load values to use when initializing the sampling space and constraining the loads. If nothing, finds the maximum load at each bus with the given relaxed model type.\n'pd_min::Array': the minimum active load values to use when initializing the sampling space and constraining the loads. If nothing, this is set to 0 for all loads.\n'pf_min::Array/Float:' the minimum power factor for all loads in the system (Number) or an array of minimum power factors for each load in the system.\n'pf_lagging::Bool': indicating if load power factors can be only lagging (True), or both lagging or leading (False).\n'reset_level::Integer': determines how to reset the load point to be inside the polytope before sampling. 2: Reset closer to nominal load & chebyshev center, 1: Reset closer to chebyshev center, 0: Reset at chebyshev center.\n'save_certs::Bool': specifies whether the sampling space, Ax<=b (A & b matrices) are saved to the results dictionary.\n'save_max_load::Bool': specifies whether the max active load demands used are saved to the results dictionary.\n'model_type::Type': an abstract PowerModels type indicating the network model to use for the relaxed AC-OPF formulations (Max Load & Nearest Feasible)\n'r_solver': an optimizer constructor used for solving the relaxed AC-OPF optimization problems.\n'opf_solver': an optimizer constructor used to find the AC-OPF optimal solution for each sample.\n'print_level::Integer': from 0 to 3 indicating the level of info to print to console, with 0 indicating minimum printing.\n'stat_track::Integer': from 0 to 3 indicating the level of stats info saved during each iteration\t0: No information saved, 1: Feasibility, New Certificate, Added Sample, Iteration Time, 2: Variance for all input & output variables\n'save_while::Bool': indicates whether results and stats information is saved to a csv file during processing.\n'save_infeasible::Bool': indicates if infeasible samples are saved. If true saves infeasible samples in a seperate file from feasible samples.\n'save_path::String:' a string with the file path to the desired result save location.\n'net_path::String': a string with the file path to the network file. \n'variance::Bool': indicates if dataset variance information is tracked for each unique active set.\n'discard::Bool': indicates if samples that do not increase the variance within a unique active set are discarded.\n\nSee 'OPF-Learn: An Open-Source Framework for Creating Representative AC Optimal Power Flow Datasets' for more information on how the AC OPF datasets are created. \n\nModified from AgenerateACOPFsamples.m written by Ahmed S. Zamzam\n\n\n\n\n\n","category":"function"},{"location":"datasetcreation/#OPFLearn.create_samples-2","page":"Dataset Creation","title":"OPFLearn.create_samples","text":"Loads in PowerModels network data given the name of a network case file,  then starts creating samples\n\n\n\n\n\n","category":"function"},{"location":"datasetcreation/#Distributed-Processing","page":"Dataset Creation","title":"Distributed Processing","text":"","category":"section"},{"location":"datasetcreation/","page":"Dataset Creation","title":"Dataset Creation","text":"Modules = [OPFLearn]\nPages   = [\"create_samples_distributed.jl\"]\nOrder   = [:function]\nPrivate  = false","category":"page"},{"location":"datasetcreation/#OPFLearn.dist_create_samples","page":"Dataset Creation","title":"OPFLearn.dist_create_samples","text":"Creates an AC OPF dataset for the given PowerModels network dictionary. Generates samples until one of the given stopping criteria is met.  Takes options to determine how to sample points, what information to save, and what information is printed.\n\nArguments\n\n'net::Dict': network information stored in a PowerModels.jl format specified dictionary\n'K::Integer': the maximum number of samples before stopping sampling\n'U::Float': the minimum % of unique active sets sampled in the previous 1 / U samples to continue sampling\n'S::Float': the minimum % of saved samples in the previous 1 / L samples to continue sampling\n'V::Float': the minimum % of feasible samples that increase the variance of the dataset in the previous 1 / L samples to continue sampling\n'T::Integer': the maximum time for the sampler to run in seconds.\n'max_iter::Integer': maximum number of iterations for the sampler to run for.\n'nproc::Integer': the number of processors for the sampler to run with. Defaults to the number reported by Distributed.nprocs().\n'replace_samples::Bool': whether samples in the samples channel are replaced when a new infeasibility certificate is added. Found to sometimes block progress when turned on.\n'sampler::Function': the sampling function to use. This function must take arguements A and b, and can take optional arguments.\n'sampler_opts::Dict': a dictionary of optional arguments to pass to the sampler function.\n'A::Array': defines the initial sampling space polytope Ax<=b. If not provided, initializes to a default.\n'b::Array': defines the initial sampling space polytope Ax<=b. If not provided, initializes to a default.\n'pd_max::Array': the maximum active load values to use when initializing the sampling space and constraining the loads. If nothing, finds the maximum load at each bus with the given relaxed model type.\n'pd_min::Array': the minimum active load values to use when initializing the sampling space and constraining the loads. If nothing, this is set to 0 for all loads.\n'pf_min::Array/Float:' the minimum power factor for all loads in the system (Number) or an array of minimum power factors for each load in the system.\n'pf_lagging::Bool': indicating if load power factors can be only lagging (True), or both lagging or leading (False).\n'reset_level::Integer': determines how to reset the load point to be inside the polytope before sampling. 2: Reset closer to nominal load & chebyshev center, 1: Reset closer to chebyshev center, 0: Reset at chebyshev center.\n'save_certs::Bool': specifies whether the sampling space, Ax<=b (A & b matrices) are saved to the results dictionary.\n'save_max_load::Bool': specifies whether the max active load demands used are saved to the results dictionary.\n'model_type::Type': an abstract PowerModels type indicating the network model to use for the relaxed AC-OPF formulations (Max Load & Nearest Feasible)\n'r_solver': an optimizer constructor used for solving the relaxed AC-OPF optimization problems.\n'opf_solver': an optimizer constructor used to find the AC-OPF optimal solution for each sample.\n'print_level::Integer': from 0 to 3 indicating the level of info to print to console, with 0 indicating minimum printing.\n'stat_track::Integer': from 0 to 3 indicating the level of stats info saved during each iteration\t0: No information saved, 1: Feasibility, New Certificate, Added Sample, Iteration Time, 2: Variance for all input & output variables\n'save_while::Bool': indicates whether results and stats information is saved to a csv file during processing.\n'save_infeasible::Bool': indicates if infeasible samples are saved. If true saves infeasible samples in a seperate file from feasible samples.\n'save_path::String:' a string with the file path to the desired result save location.\n'net_path::String': a string with the file path to the network file. \n'variance::Bool': indicates if dataset variance information is tracked for each unique active set.\n'discard::Bool': indicates if samples that do not increase the variance within a unique active set are discarded.\n\nSee 'OPF-Learn: An Open-Source Framework for Creating Representative AC Optimal Power Flow Datasets' for more information on how the AC OPF datasets are created. \n\nModified from AgenerateACOPFsamples.m written by Ahmed S. Zamzam\n\n\n\n\n\n","category":"function"},{"location":"datasetcreation/#OPFLearn.dist_create_samples-2","page":"Dataset Creation","title":"OPFLearn.dist_create_samples","text":"Loads in PowerModels network data given the name of a network case file,  then starts creating samples with distributed processing\n\n\n\n\n\n","category":"function"},{"location":"python/#Python-Interface","page":"Python Interface","title":"Python Interface","text":"","category":"section"},{"location":"python/","page":"Python Interface","title":"Python Interface","text":"A Python package to interface OPFLearn with Python can be found at opflearn. This package utilizes PyJulia to allow Python users to create datasets from a Python enviroment.  A guide on how to install PyJulia and run Julia scripts from Python can be found here.  Once Julia is installed, the OPFLearn package must be installed as shown in the Installation section.","category":"page"},{"location":"python/","page":"Python Interface","title":"Python Interface","text":"The opflearn Python package is NOT on the Python Package Index Repository, so it has to be install from GitHub as follows,","category":"page"},{"location":"python/","page":"Python Interface","title":"Python Interface","text":"pip install git+https://github.com/TragerJoswig-Jones/opflearn.git","category":"page"},{"location":"python/","page":"Python Interface","title":"Python Interface","text":"The Python interface has most of the same Julia functions from OPFLearn.jl as callable Python functions, but not all. For functions that are not included in the interface, PyJulia calls can be used.","category":"page"},{"location":"python/","page":"Python Interface","title":"Python Interface","text":"note: Note\nThis Python interface sometimes requires using values from NumPy and does not allow for passing in modular functions.","category":"page"},{"location":"sampling/#Sampling-Functions","page":"Sampling","title":"Sampling Functions","text":"","category":"section"},{"location":"sampling/","page":"Sampling","title":"Sampling","text":"Modules = [OPFLearn]\nPages   = [\"sample.jl\"]\nOrder   = [:function]\nPrivate  = false","category":"page"},{"location":"sampling/#OPFLearn.sample_polytope_cprnd","page":"Sampling","title":"OPFLearn.sample_polytope_cprnd","text":"Translated to Julia and modified based on: https://www.mathworks.com/matlabcentral/fileexchange/34208-uniform-distribution-over-a-convex-polytope Copyright (c) 2011-2012 Tim J. Benham, School of Mathematics and Physics, University of Queensland.\n\nCPRND Draw from the uniform distribution over a convex polytope. \tX = cprnd(N,A,b) Returns an N-by-P matrix of random vectors drawn \tfrom the uniform distribution over the interior of the polytope \tdefined by Ax <= b. A is a M-by-P matrix of constraint equation \tcoefficients. b is a M-by-1 vector of constraint equation \tconstants\n\n...\n\n'method::String': 'gibbs': Gibbs sampler, 'hitandrun': Hit and Run, 'achr': Adaptive Centering Hit-and-Run\n'iso::Integer': Isotropic Transformation (0: no xfrm, 1: Xfrm during runup, 2: Xfrm throughout sampling\n'runup::Integer': # of initial iterations of the algorithm in the untransformed space for gibbs or hitandrun\n'discard::Integer': # of initial samples (post runup) to discard. Randomly selects nsamples from the \n\n\tdiscard + n_samples samples.\n\n...\n\n\n\n\n\n","category":"function"},{"location":"sampling/#OPFLearn.sample_uniform","page":"Sampling","title":"OPFLearn.sample_uniform","text":"Used to call sampleuniform from createsamples\n\n\n\n\n\n","category":"function"},{"location":"sampling/#OPFLearn.sample_uniform-Tuple{Any}","page":"Sampling","title":"OPFLearn.sample_uniform","text":"Samples from a uniform distribution of the given percentage  around the given base load, x0 = (pd\\0 + qd_0). Power factors are held constant.\n\nxil = U[0.8 xi0, 1.2 x_i0] for all i in load buses\n\n\n\n\n\n","category":"method"},{"location":"sampling/#OPFLearn.sample_uniform_w_pf","page":"Sampling","title":"OPFLearn.sample_uniform_w_pf","text":"Used to call sampleuniformwpf from createsamples\n\n\n\n\n\n","category":"function"},{"location":"sampling/#OPFLearn.sample_uniform_w_pf-Tuple{Any}","page":"Sampling","title":"OPFLearn.sample_uniform_w_pf","text":"Samples from a uniform distribution of the given percentage  around the given base load real power, pd0. Then sample a  power factor from the given pfrange to determine the reactive load of the sample. By default the pf_range refers to lagging  power factors. If a value larger than 1.0 is given in the range, it will be converted to a leading power factor of pf = (1.0 - x).\n\np_il = U[(1-dist) * pi0, (1+dist) * p\\i0] for all i in load buses\nd_il = U[pf_range] for all i in load buses\nq_il = tan(d_il) * p_il\n\n\n\n\n\n","category":"method"},{"location":"distributed/#distributed_processing","page":"Distributed Processing","title":"Distributed Processing","text":"","category":"section"},{"location":"distributed/","page":"Distributed Processing","title":"Distributed Processing","text":"Dataset creation can be sped up by using distributed processing.  Before beginning distributed dataset creation, the user must create worker processes through the Distributed package.  A simple way to do this when running distributed processes locally on a single computer is as follows, ","category":"page"},{"location":"distributed/","page":"Distributed Processing","title":"Distributed Processing","text":"# Create worker processes\nnproc = 4 # The desired number of CPUs to run with\n# Clear any existing worker processes if present\nDistributed.nprocs() > 1 && Distributed.rmprocs(Distributed.workers())\n# Create worker processes\nDistributed.addprocs(nproc - 1; exeflags=\"--project\")\n# Import functions used on all worker processes\nDistributed.@everywhere using OPFLearn","category":"page"},{"location":"distributed/","page":"Distributed Processing","title":"Distributed Processing","text":"The create_samples function has a distributed alternative, dist_create_samples.","category":"page"},{"location":"distributed/","page":"Distributed Processing","title":"Distributed Processing","text":"dist_create_samples","category":"page"},{"location":"distributed/#OPFLearn.dist_create_samples","page":"Distributed Processing","title":"OPFLearn.dist_create_samples","text":"Loads in PowerModels network data given the name of a network case file,  then starts creating samples with distributed processing\n\n\n\n\n\nCreates an AC OPF dataset for the given PowerModels network dictionary. Generates samples until one of the given stopping criteria is met.  Takes options to determine how to sample points, what information to save, and what information is printed.\n\nArguments\n\n'net::Dict': network information stored in a PowerModels.jl format specified dictionary\n'K::Integer': the maximum number of samples before stopping sampling\n'U::Float': the minimum % of unique active sets sampled in the previous 1 / U samples to continue sampling\n'S::Float': the minimum % of saved samples in the previous 1 / L samples to continue sampling\n'V::Float': the minimum % of feasible samples that increase the variance of the dataset in the previous 1 / L samples to continue sampling\n'T::Integer': the maximum time for the sampler to run in seconds.\n'max_iter::Integer': maximum number of iterations for the sampler to run for.\n'nproc::Integer': the number of processors for the sampler to run with. Defaults to the number reported by Distributed.nprocs().\n'replace_samples::Bool': whether samples in the samples channel are replaced when a new infeasibility certificate is added. Found to sometimes block progress when turned on.\n'sampler::Function': the sampling function to use. This function must take arguements A and b, and can take optional arguments.\n'sampler_opts::Dict': a dictionary of optional arguments to pass to the sampler function.\n'A::Array': defines the initial sampling space polytope Ax<=b. If not provided, initializes to a default.\n'b::Array': defines the initial sampling space polytope Ax<=b. If not provided, initializes to a default.\n'pd_max::Array': the maximum active load values to use when initializing the sampling space and constraining the loads. If nothing, finds the maximum load at each bus with the given relaxed model type.\n'pd_min::Array': the minimum active load values to use when initializing the sampling space and constraining the loads. If nothing, this is set to 0 for all loads.\n'pf_min::Array/Float:' the minimum power factor for all loads in the system (Number) or an array of minimum power factors for each load in the system.\n'pf_lagging::Bool': indicating if load power factors can be only lagging (True), or both lagging or leading (False).\n'reset_level::Integer': determines how to reset the load point to be inside the polytope before sampling. 2: Reset closer to nominal load & chebyshev center, 1: Reset closer to chebyshev center, 0: Reset at chebyshev center.\n'save_certs::Bool': specifies whether the sampling space, Ax<=b (A & b matrices) are saved to the results dictionary.\n'save_max_load::Bool': specifies whether the max active load demands used are saved to the results dictionary.\n'model_type::Type': an abstract PowerModels type indicating the network model to use for the relaxed AC-OPF formulations (Max Load & Nearest Feasible)\n'r_solver': an optimizer constructor used for solving the relaxed AC-OPF optimization problems.\n'opf_solver': an optimizer constructor used to find the AC-OPF optimal solution for each sample.\n'print_level::Integer': from 0 to 3 indicating the level of info to print to console, with 0 indicating minimum printing.\n'stat_track::Integer': from 0 to 3 indicating the level of stats info saved during each iteration\t0: No information saved, 1: Feasibility, New Certificate, Added Sample, Iteration Time, 2: Variance for all input & output variables\n'save_while::Bool': indicates whether results and stats information is saved to a csv file during processing.\n'save_infeasible::Bool': indicates if infeasible samples are saved. If true saves infeasible samples in a seperate file from feasible samples.\n'save_path::String:' a string with the file path to the desired result save location.\n'net_path::String': a string with the file path to the network file. \n'variance::Bool': indicates if dataset variance information is tracked for each unique active set.\n'discard::Bool': indicates if samples that do not increase the variance within a unique active set are discarded.\n\nSee 'OPF-Learn: An Open-Source Framework for Creating Representative AC Optimal Power Flow Datasets' for more information on how the AC OPF datasets are created. \n\nModified from AgenerateACOPFsamples.m written by Ahmed S. Zamzam\n\n\n\n\n\n","category":"function"},{"location":"distributed/","page":"Distributed Processing","title":"Distributed Processing","text":"The distributed sample creation function has the same arguments as the single process function, except for the addition of two arguments: nproc and replace_samples.","category":"page"},{"location":"distributed/","page":"Distributed Processing","title":"Distributed Processing","text":"nproc allows the user to specify the number of processor to run the distributed sample creation with.\nreplace_samples specifies whether when a new infeasibility certificate is found if the samples in the sample queue are replaced.","category":"page"},{"location":"distributed/","page":"Distributed Processing","title":"Distributed Processing","text":"warn: Warn\nThe replace samples option has not been fully tested/debugged and may cause the script to freeze.","category":"page"},{"location":"distributed/","page":"Distributed Processing","title":"Distributed Processing","text":"Distributed processing splits the sampling/result handling from the sample processing with one processor handling sampling and the remaining processors processing samples.","category":"page"},{"location":"distributed/","page":"Distributed Processing","title":"Distributed Processing","text":"note: Note\nA significant increase in speed is not seen unless more than 3 processors are used. On the other hand, specifying more processors than are available may result in an error when loading OPFLearn on distributed processes.","category":"page"},{"location":"#OPFLearn.jl-Documentation","page":"Home","title":"OPFLearn.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OPFLearn","category":"page"},{"location":"#Package-Overview","page":"Home","title":"Package Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OPFLearn.jl is a Julia package for creating datasets for machine learning approaches to solving AC optimal power flow (AC OPF). It was developed to provide researchers with a standardized way to efficiently create AC OPF datasets that are representative of more of the AC OPF feasible load space compared to typical dataset creation methods. The OPFLearn dataset creation method uses a relaxed AC OPF formulation to reduce the volume of the unclassified input space throughout the dataset creation process.  Over time this input space tightens around the relaxed AC OPF feasible region to increase the percentage of feasible load profiles found while uniformly sampling the input space. Load samples are processed using AC OPF formulations from PowerModels.jl. More information on the dataset creation method can be found in our publication, \"OPF-Learn: An Open-Source Framework for Creating Representative AC Optimal Power Flow Datasets\". A Python interface for OPFLearn.jl is available at opflearn.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you haven’t already, your first step should be to install Julia. Instructions are available at julialang.org/downloads.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Installing OPFLearn can now be done using the Julia package manager.","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add OPFLearn","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the development version of OPFLearn, install the package with,","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add OPFLearn#main","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default OPFLearn uses IPOPT to solve AC OPF problems, which comes installed as a dependancy of OPFLearn. When using different formulations for relaxed AC OPF problems, such as a Semidefinite Relaxation, additional solvers are required.  For conic AC OPF formulations a conic solver must be installed. OPFLearn was tested with the SCS solver, which can be installed with","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add SCS","category":"page"},{"location":"","page":"Home","title":"Home","text":"Testing that the OPFLearn package works properly can be done with ","category":"page"},{"location":"","page":"Home","title":"Home","text":"] test OPFLearn","category":"page"},{"location":"","page":"Home","title":"Home","text":"To test distributed dataset creation the following commands can be entered in the REPL, where nproc is the number of processors to run the test with as a string.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nnproc = \"4\"\nPkg.test(\"OPFLearn\"; test_args = [nproc])","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nOPFLearn can take a while to start up on the first run of each session as Julia takes a notable amount of time to precompile IPOPT. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"warn: Warn\nIn the current release of OPFLearn the distributed dataset creation tests can get stuck loading packages on distributed processors.  If you run into this issue, you can inturrupt these tests with 'ctrl+c'. ","category":"page"}]
}
